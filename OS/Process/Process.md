# 프로세스란?

**프로세스**는 메모리에서 실행 중인 프로그램입니다.

---

## 프로세스 메모리 구조

> - **Code**: 실행 가능한 명령어가 저장된 영역으로, 일반적으로 읽기 전용입니다.
> - **Stack**: 함수 매개변수, 반환 주소, 지역 변수 등과 같은 임시 데이터가 저장됩니다. 함수 호출 시 생성되며, 호출이 끝나면 자동으로 해제됩니다 (LIFO 구조).
> - **Data**: 전역 변수 및 정적 변수가 저장되는 영역입니다.
> - **Heap**: 실행 시간 동안 동적으로 할당되는 메모리 공간입니다.

---

## 프로세스의 속성

운영 체제는 프로세스를 관리하고 제어하기 위해 **프로세스 제어 블록(PCB)**에 관련 정보를 저장합니다.

### PCB에 저장되는 주요 정보:

> - **프로세스 ID (PID)**: 각 프로세스를 구분하는 고유 번호
> - **프로세스 상태**: 실행 중, 대기 중, 준비 상태 등
> - **우선순위 및 CPU 스케줄링 정보**
> - **I/O 정보**: 사용 중인 입출력 장치 정보
> - **파일 설명자**: 열려 있는 파일과 네트워크 연결 정보
> - **회계 정보**: 실행 시간, CPU 사용 시간 등
> - **메모리 관리 정보**: 스택, 힙 등을 포함한 메모리 구조 정보

---

## 프로세스 라이프사이클 (Process Lifecycle)

프로그램이 실행되어 프로세스가 되면, 종료되기까지 여러 단계를 거칩니다. 운영 체제에 따라 상태의 수는 다를 수 있으며, 일반적으로는 2, 5, 7단계 모델로 구분됩니다.

### Two-State Model

> - **Running**: 프로세스가 CPU를 사용하여 작업을 수행 중인 상태입니다.
> - **Not Running**: 프로세스가 CPU를 사용하지 않고 대기 중인 상태입니다. 사용자 입력이나 이벤트를 기다리는 경우입니다.

### Five-State Model

> - **New**: 새로 생성된 프로세스로, 아직 실행되지 않은 상태입니다.
> - **Ready**: CPU 할당을 기다리며 실행 준비가 된 상태입니다.
> - **Running**: 현재 CPU에서 실행 중인 상태입니다.
> - **Waiting** (또는 **Blocked**): I/O 등의 이벤트를 기다리며 일시 정지된 상태입니다.
> - **Terminated**: 실행이 완료되어 종료된 상태입니다.

### Seven-State Model

> - **New**: 프로그램이 선택되어 아직 생성되지 않은 초기 상태입니다.
> - **Ready**: 프로세스가 메모리에 로드되어 실행을 기다리는 상태입니다.
> - **Running**: CPU에서 명령을 실행 중인 상태입니다.
> - **Waiting** (또는 **Blocked**): 이벤트나 리소스를 기다리는 상태입니다.
> - **Terminated**: 실행이 완료되어 시스템 자원이 해제된 상태입니다.
> - **Suspended Ready**: 메모리 부족 등으로 보조 기억장치로 옮겨진 준비 상태입니다.
> - **Suspended Blocked**: 차단된 상태에서 동시에 메모리에서 스왑된 상태입니다.

---

## 프로세스 작업 (Operation on the Process)

운영 체제는 프로세스의 생명 주기 동안 다양한 작업을 수행하며, 이를 통해 프로세스를 생성하고 실행하며 종료까지 관리합니다.

> ### 생성 (Creation)
> 프로세스가 생성되면 준비 상태(Ready)가 되어 준비 큐(메인 메모리)에 등록됩니다. 이 단계에서 프로세스는 실행을 위해 대기하는 상태입니다.
>
> ### 스케줄링 (Planning)
> 운영 체제는 준비 큐에 있는 여러 프로세스 중 하나를 선택하여 실행을 시작합니다. 이 과정을 스케줄링(Scheduling)이라고 하며, 어떤 프로세스를 먼저 실행할지 결정하는 핵심 절차입니다.
>
> ### 실행 (Application)
> 프로세스가 스케줄링되면 CPU는 해당 프로세스를 실행합니다. 실행 도중 프로세스는 차단(Blocked)되거나 대기 상태가 될 수 있으며, 이 경우 CPU는 다른 프로세스를 실행하도록 전환됩니다.
>
> ### 종료 또는 삭제 (Killing or Deletion)
> 프로세스의 목적이 완료되면 운영 체제는 해당 프로세스를 종료합니다. 이때 프로세스의 컨텍스트는 소멸되고, 할당된 자원은 해제됩니다.
>
> ### 차단 (Blocking)
> 프로세스가 이벤트나 리소스를 기다려야 하는 상황에서는 차단 상태(Blocked)로 전환됩니다. 이 상태에서는 해당 이벤트나 리소스가 사용 가능해질 때까지 실행되지 않습니다.
>
> ### 재개 (Resumption)
> 프로세스를 차단했던 이벤트나 리소스가 사용 가능해지면, 프로세스는 차단 상태에서 제거되어 준비 큐로 다시 이동합니다. 이후 다시 실행될 수 있습니다.
>
> ### 컨텍스트 전환 (Context Switching)
> 운영 체제가 한 프로세스에서 다른 프로세스로 전환할 때, 현재 프로세스의 컨텍스트(상태)를 저장하고, 다음 프로세스의 컨텍스트를 불러와 실행합니다. 이 과정을 컨텍스트 전환(Context Switching)이라고 합니다.
>
> ### 프로세스 간 통신 (Inter-Process Communication, IPC)
> 프로세스는 데이터를 공유하거나 작업을 조정하기 위해 서로 통신해야 할 수 있습니다. 운영 체제는 공유 메모리(Shared Memory), 메시지 전달(Message Passing), 동기화 도구(Synchronization Primitives) 등 다양한 통신 메커니즘을 제공합니다.
>
> ### 프로세스 동기화 (Process Synchronization)
> 여러 프로세스가 동시에 공유 자원이나 임계 구역(Critical Section)에 접근해야 하는 경우가 있습니다. 이때 운영 체제는 동기화 메커니즘을 제공하여, 한 번에 하나의 프로세스만 접근할 수 있도록 보장합니다.
>
> ### 프로세스 상태 (Process States)
> 프로세스는 Ready, Running, Waiting, Terminated 등의 상태 중 하나일 수 있습니다. 운영 체제는 이 상태들을 관리하며, 상태 간 전이를 효율적으로 수행합니다.


---

## 운영 체제에서의 프로세스 생성 및 삭제

프로세스는 **생성 → 실행 → 삭제** 단계로 수명 주기를 가집니다.

### 프로세스 생성 절차

> 1. 운영 체제는 고유한 PID를 부여하고 프로세스 테이블에 등록
> 2. 필요한 메모리 공간 할당 (코드, 데이터, 스택, PCB 등)
> 3. PCB 초기화 (스택 포인터, 프로그램 카운터 등 설정)
> 4. 상태를 'New' → 'Ready'로 변경하고 스케줄링 대기열에 등록
> 5. 로그나 회계 파일 등 추가 데이터 구조 생성

### 부모-자식 프로세스

- 새 프로세스를 생성한 프로세스를 **부모 프로세스**, 생성된 프로세스를 **자식 프로세스**라 합니다.

---

## 시스템 콜을 통한 프로세스 생성

### UNIX

- `fork()`: 현재 프로세스를 복사하여 자식 프로세스를 생성
- `exec()`: 현재 프로세스를 새로운 프로그램으로 대체
- `waitpid()`: 부모 프로세스가 자식 프로세스 종료를 기다림

### Windows

- `CreateProcess()`: 프로세스를 생성하고 지정된 프로그램을 실행
    - `fork()`와 `exec()`의 기능을 결합
    - 환경, 보안 설정 등 세부 제어 가능

---

## 프로세스 삭제

프로세스는 실행 완료 후 **exit()** 시스템 호출을 통해 종료되며, 운영 체제는 리소스를 회수합니다.

### 종료 유형

> - **정상 종료**: 작업 완료 후 `exit()` 호출
> - **비정상 종료**: 오류 발생 시 `abort()` 호출 등으로 종료
> - **부모 프로세스에 의한 종료**: `kill()` 시스템 호출로 자식 프로세스를 종료
> - **신호에 의한 종료**: `SIGKILL`, `SIGSTOP` 등의 신호로 종료

---

