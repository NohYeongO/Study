# 스레드 종류와 실행 구조 정리

---

### 커널(Kernel)이란?

>- 운영체제의 **핵심 시스템**으로, 하드웨어와 소프트웨어 사이를 중재함
>- **CPU, 메모리, 파일 시스템, 입출력 장치** 등 모든 자원을 관리함
>- 사용자 프로그램은 직접 하드웨어에 접근하지 못하고, **커널을 통해서만 자원 사용 가능**

>→ 커널 스레드는 이 **커널이 직접 생성하고 스케줄링하는 실행 단위**임

---

### 컨텍스트 스위칭(Context Switching)이란?

>- CPU가 현재 실행 중인 스레드나 프로세스의 상태(레지스터, 프로그램 카운터 등)를 저장하고,  
  다음에 실행할 스레드의 상태를 불러오는 작업
>- 이 과정을 통해 CPU는 여러 스레드를 번갈아 실행할 수 있음
>- **커널이 직접 개입**하며, 이로 인해 일정한 **오버헤드(성능 손실)** 가 발생함

---

## 하드웨어 스레드 (Hardware Thread)

### 하드웨어 스레드란?

> - CPU 내부에 있는 **물리적인 실행 단위**
> - 하나의 CPU 코어가 여러 개의 하드웨어 스레드를 가질 수 있음 (ex. 하이퍼스레딩)
> - 실제 병렬 처리를 담당하는 "손"

### 예시
> - 4코어 8스레드 → 물리 코어 4개 × 하드웨어 스레드 2개
> - 최대 8개의 작업을 병렬 처리할 수 있음

---

## 커널 스레드 (Kernel Thread)

### 커널 스레드란?

> - 운영체제 커널이 직접 생성하고 관리하는 스레드
> - 실제 CPU에서 실행되는 논리적 실행 단위
> - 커널이 직접 스케줄링, 상태 전이, 컨텍스트 스위칭 등을 수행함

---

### 하드웨어 스레드와의 관계
> - 커널 스레드는 실행할 작업을 담고 있는 단위
> - 하드웨어 스레드는 실제 명령어를 실행하는 물리적 유닛
> - 커널은 스케줄러를 통해 커널 스레드를 하드웨어 스레드에 배정함


---

## 유저 스레드 (User-Level Thread)

### 유저 스레드란?

>- 운영체제가 아닌 사용자 코드에서 직접 관리되는 스레드
>- 커널에는 등록되지 않기 때문에, 운영체제는 해당 스레드의 존재를 모름
>- 생성, 스케줄링, 종료 모두 사용자 공간에서 처리됨

### 특징

>- 빠르고 가벼움 (컨텍스트 스위칭 시 커널 개입 없음)
>- 다만 한 스레드가 Block되면 전체가 멈춤
>- 커널은 하나의 단일 프로세스로만 인식하므로 멀티코어 활용 불가

---
## Java Thread 생명주기

>- **NEW**: 스레드가 생성되었지만 `start()` 호출 전의 상태
>- **RUNNABLE**: 실행 가능한 상태로, CPU 할당을 기다림
>- **TIMED_WAITING**: 정해진 시간 동안 대기 (`sleep()`, `join(ms)` 등)
>- **WAITING / BLOCKED**: 조건 또는 락을 기다리는 상태 (`wait()`, 동기화 등)
>- **TERMINATED**: 스레드 실행이 끝났거나 예외로 종료된 상태


## Kernel Thread 생명주기

>- **NEW**: 커널 스레드가 생성되었지만 아직 준비 큐에 등록되지 않은 상태
>- **READY**: 실행 가능한 상태로, CPU 할당을 기다리며 Run Queue에서 대기
>- **RUNNING**: 커널 스레드가 CPU에 배정되어 실제로 실행 중인 상태
>- **BLOCKED / WAITING**: I/O 요청, 락, 이벤트 등의 이유로 대기 중인 상태
>- **TERMINATED**: 실행이 완료되어 커널이 자원을 정리 중이거나 종료된 상태

---

## 자바 스레드와 커널 스레드의 관계 정리

### 기본 개념

>- 자바 스레드는 JVM에서 생성되는 논리적인 실행 단위
>- 커널 스레드는 운영체제에서 생성되고 관리되는 물리적인 실행 단위
>- 자바 스레드는 실제로 커널 스레드를 통해 실행된다

---

### 1:1 매핑 관계

>- 자바 스레드는 생성 시 운영체제에 커널 스레드 생성을 요청
>- 생성된 커널 스레드는 자바 스레드와 1:1로 연결됨 (One-to-One Thread Model)
>- 이 구조를 통해 자바는 운영체제의 멀티코어 병렬 처리 능력을 활용할 수 있음

---

### 실행 흐름

>1. `new Thread()` → JVM이 자바 스레드 생성
>2. `start()` 호출 → 시스템 콜을 통해 커널 스레드 생성 요청
>3. 커널 스레드 생성 → 자바 스레드와 1:1 매핑
>4. 커널 스레드는 운영체제 스케줄러에 의해 실행 순서 결정
>5. 자바 스레드는 커널 스레드를 통해 자바 코드 실행

---

### 상태 관리의 차이

>- 자바 스레드는 자바 코드 흐름에 따라 상태가 바뀜 (`sleep()`, `wait()` 등)
>- 커널 스레드는 CPU 점유, 시스템 콜, I/O 등 운영체제 관점에서 상태가 바뀜
>- 1:1로 매핑되어 있어도, 상태는 항상 일치하지 않음

> 자바 스레드는 JVM에서 safepoint에 도달하여 논리적으로 멈췄어도,  
> JVM은 커널 스레드의 상태를 직접 바꾸지 않기 때문에 자바 스레드의 상태는 여전히 RUNNABLE일 수 있다

---

## Safepoint란?

>- Safepoint는 JVM이 자바 스레드의 상태가 완전히 파악 가능한 시점을 의미함
>- 이 시점에서는 해당 스레드의 스택 내 참조 정보, 실행 위치 등이 명확하게 식별되어  
  GC나 클래스 언로드 등의 작업을 안전하게 수행할 수 있음

---

## Safepoint Polling이란?

>- JVM은 자바 스레드를 강제로 멈출 수 없기 때문에  
  자바 스레드가 주기적으로 "멈춰야 하는지"를 확인(polling)하도록 설계됨
>- 이 과정을 Safepoint Polling이라고 하며,  
  JVM 내부에서 safepoint 요청이 발생하면  
  자바 스레드는 실행 중간 중간 safepoint 플래그를 체크하고 멈춘다

### 자주 polling이 발생하는 지점

>- 바이트코드 해석 중: 거의 모든 명령 사이
>- JIT 컴파일된 코드: 메서드 진입/탈출, 루프 백 엣지(back edge) 등

---

### GC와 STW(Stop-the-World)

>- GC 수행을 위해 JVM은 모든 자바 스레드를 safepoint로 진입시킴
>- JVM은 safepoint 플래그를 켜고, 자바 스레드들이 polling을 통해 이를 감지하고 스스로 멈춤
>- 이때 JVM 스레드는 멈추지만, JVM은 커널 스레드 상태를 변경하지 않기 때문에  
  자바 스레드의 상태는 RUNNABLE로 유지된다
>- 모든 스레드가 safepoint에 진입한 후 GC를 수행

---

### 결론

>- 자바 스레드는 커널 스레드 위에서 동작하는 실행 단위
>- 커널 스레드의 지원 없이는 자바 스레드의 병렬 실행이 불가능
>- 자바 스레드 = JVM이 관리하는 논리적 단위  
  커널 스레드 = 운영체제가 관리하는 물리적 단위
>- Safepoint는 JVM의 내부 정지점이며,  
  JVM은 safepoint polling을 통해 자바 스레드를 멈춘다
>- JVM이 스레드 상태를 OS에 반영하는 게 아니기 때문에  
  자바 스레드는 논리적으로 멈췄어도 상태는 RUNNABLE로 유지될 수 있다
